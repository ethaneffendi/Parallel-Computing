<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="" />
  <title>Supervised Learning</title>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <link href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
  <hr>

  <!--Threads and Processes in Python-->
  <h1 class="text">Threads and Processes in Python</h1>
  <p class="text">
    In Python, a running instance of a full application is called a process.
    One process can be broken up into many smaller tasks that work together to make the full app run smoothly.
    These smaller tasks are called threads.
    The operating system a process is being run in manages how and when threads are executed.
  </p>
  <p class="text">
    Single-threading is the practice of having the multiple threads in one process run sequentially.
    Each thread waits for the one before it to finish before executing.
    If one thread takes a long time to execute, however, it becomes a bottleneck.
    The solution to this inefficiency is multithreading.
    Multithreading is the practice of allowing more than one thread to execute simultaneously.
    In particular, multiple threads are executed simultaneously using a technique called time slicing.
    The CPU switches between working on different threads so quickly that it seems as though the threads are running in parallel.
    Threads in the same process share the same resources (namely memory), so synchronization is necessary.
    Mechanisms exist for ensuring that no more than one concurrent thread can process and execute a particular portion of a program at once.
    Restricting execution of these special portions of code, called critical sections, to one thread at a time prevents data conflicts that might happen when two or more threads are reading and writing from the same shared memory.
    For working with threads and implementing multithreading, Python has a module called <code>threading</code>.
  </p>
  <p class="text">
    For true parallelism in Python, one must work with processes.
    Multiprocessing is the practice of distributing concurrent processes among multiple CPUs (usually the cores in a multicore processor) that work in parallel.
    In Python, working with processes and implementing multiprocessing can be done using the <code>multiprocessing</code> module. Downsides to multiprocessing exist, however.
    For example, concurrent processes do not share memory.
    They communicate with one another through interprocess communication methods provided by the operating system.
    Thus, communication among processes is not as efficient or quick as communication among threads.
    Also, a process is heavier than a thread.
    Context switching between different processes (pausing the current process to work on another) takes more time than context switching between different threads.
  </p>
  <img src="(1) Threads and Processes in Python/Threads and Processes.png" width=45%>
  <hr>

  <!--The threading Module-->
  <h1 class="text">The <code>threading</code> Module</h1>
  <p class="text">
    To create and customize thread objects using <code>threading</code>, one must follow several steps.
  </p>
  <ol>
    <li>
      Define a subclass of <code>threading.Thread</code>.
    </li>
    <li>
      Override <code>__init__(self [,args])</code> in the subclass of <code>threading.Thread</code> for custom parameters that will be used to provide the thread with needed data.
    </li>
    <li>
      Override <code>run(self [,args])</code> to define what a thread should do when executed.
    </li>
    <li>
      Execute the thread by calling its <code>start()</code> function, which will in turn call <code>run()</code>.
    </li>
    <li>
      To make sure that Python waits for all threads that have been created and executed to finish before it moves to the sequentially next part of the program, call the <code>join()</code> function on each thread.
    </li>
  </ol>
  <script src="https://gist.github.com/ethaneffendi/f7e23ae9de8d76afaf149b36e921facd.js"></script>
  <p class="text">
    The code above makes a thread for each job that needs to be done.
    What if a thousand tasks need to be completed though?
    Wouldn't it be more efficient to just have five or so threads that split the work instead of making one thousand threads?
    The solution is using Python's <code>queue</code> module.
    Queues are a FIFO data structure that are useful for doing the same job on thousands of different inputs.
    Each thread's <code>run()</code> function will use a while true loop to pop an input out of the queue (try-except-else block) and process it using another function.
  </p>
  <hr>

  <!--The multiprocessing Module-->
  <h1 class="text">The <code>multiprocessing</code> Module</h1>
  <p class="text">
    Similar to working with threads in <code>threading</code>, one can make a process in <code>multiprocessing</code> by subclassing <code>multiprocessing.Process</code>, overriding the subclass's initializer, overriding the subclass's <code>run</code> function, and calling <code>start()</code> and <code>join()</code> in Python's main process.
    However, an alternative way of making processes exists. In Python's main process, one can instantiate <code>Process</code> with a <code>target</code> argument that is the function the process should run. The process receives the arguments of the function passed as an argument to the <code>target</code> parameter via a tuple passed to the <code>args</code> parameter of the constructor.
  </p>
  <script src="https://gist.github.com/ethaneffendi/45bb3474df2d4031346264933ada804f.js"></script>
  <p class="text">
    Python's <code>multiprocessing</code> module provides another solution for running processes in parallel. If the same function needs to be run on a collection of data, one should use the <code>multithreading.Pool</code> class.
    It takes a function and a collection. It runs the function on each member of the collectin as input and returns an output collection such that every element of the output corresponds by index to every element of the input.
  </p>
  <script src="https://gist.github.com/ethaneffendi/9186850b9b86677b123de3fa257dec05.js"></script>
  <hr>

  <!--A Very Brief Introduction to Patterns-->
  <h1 class="text">A Very Brief Introduction to Patterns</h1>
  <p class="text">
    Just as there are numerous data structures and algorithms to choose from when solving sorting or searching problems, there are many different patterns one can use for implementing parallelism in any program.
    Knowing which pattern fits which problem is key to being a master of parallelism. Thus, exploring different patterns and their uses will be the main focus from here on out.
  </p>
  <hr>

  <!--Map-->
  <h1 class="text">Map</h1>
  <p class="text">
    Map is one of many parallel patterns.
    It is the parallel equivalent of the kind of for loop in which each iteration of the loop body is independent of the others.
    What happens in the loop body of map's serial equivalent is called the elemental function in parallelism terms.
    A map takes in a collection as input.
    Each instance of the elemental function processes an entry from the input collection to produce an output collection of equal shape.
  </p>
  <img src="(5) Map/Parallel Map vs. For Loop With Independent Iterations.png" width=45%>
  <p>
    Map is useful for applications like computing the Mandelbrot set, ray tracing, and Monte Carlo sampling.
  </p>
</body>
</html>
